#pragma once

namespace cx {

// Own pair implementation is used since the standard version does not have
// constexpr assignment operator
template <typename First, typename Second>
struct pair {
  using FirstType = First;
  using SecondType = Second;

  // [?] Why constexpr constructor and assignment are automatically generated?
  // [?] What methods are by default constexpr?
  // [?] When {} is required and when is not?

  First first;
  Second second;
};

// Required for comparison. [?] Why not generated by default
template <typename First, typename Second>
constexpr bool operator==(const pair<First, Second>& lhs, const pair<First, Second>& rhs) {
  return lhs.first == rhs.first && lhs.second == rhs.second;
}

// Required for comparison. [?] Why not generated by default
template <typename First, typename Second>
constexpr bool operator!=(const pair<First, Second>& lhs, const pair<First, Second>& rhs) {
  return !(lhs == rhs);
}

template <typename First, typename Second>
constexpr pair<First, Second> make_pair(First first, Second second) {
  return {first, second};
}

}  // namespace cx
