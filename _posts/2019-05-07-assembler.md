---
layout: post
title: Ассемблер
author: siri3us
categories: C++
toc: true
---

* https://xakep.ru/2017/09/11/asm-course-1/
* https://xakep.ru/2016/12/08/reversing-malware-tutorial-part1/
* https://ru.wikibooks.org/wiki/Ассемблер_в_Linux_для_программистов_C


Также следует сказать несколько слов о том, какой именно ассемблер выбрать для той или другой операционной среды. 

## Архитектура

### Синтаксис
Для работы с процессорами х86 используются два типа синтаксиса ассемблера &mdash; это синтаксис **AT&T** и синтаксис **Intel**. Эти синтаксисы представляют одни и те же команды совершенно по-разному. Например, команда в синтаксисе Intel выглядит так:
```
mov
```

* AT&T больше распространен в UNIX-системах.
* Intel больше распространен в Windows-системах.

С помощью `gcc` можно 
```
$ gcc main.c -S main.s -masm=intel
$ gcc main.c -S main.s -masm=att
```
По умолчанию используется `att` (AT&T).


Общий формат записи инструкций одинаков для обоих стандартов:
```
[метка:] опкод [операнды] [;комментарий]
```


Команда ассемблера состоит из операции и операнда/операндов

Синтаксис Intel и синтаксис AT&T. Можно указать, какой стоит использовать, передав gcc дополнительные опции:
```
-S -masm=intel
```

GCC генерируем много лишних макросов, начинающихся с точки. Избавиться от них можно с помощью флага
```
-fno-asynchronous-unwind-tables
```


## Задание данных в программе на ассемблере
Три секции данных:
* .data
* .rodata
* .bss

Всегда полезно вручную посмотреть, какой ассемблерный код генерирует компилятор.


TODO: Могут ли секции повторяться?

```
.data
array:
	.long 1
	.long 2
	.long 3
```
То же самое можно сделать быстрее:
```
.data
array:
	.long 1, 2, 3
```

* Секция BSS. Изначально от **Block Started by Symbol**. Но жаргонное имя "**Better Save Space**"
```
.bss
.space a 128
.space b 8
.space c 64
```

Какие данные помещаются в .bss? Предположение: неинициализированные глобальные POD с локальной областью видимости (static local variables)



* Операция присваивания значения mov
```
mov{b,w,l,q} {константа, адрес, регистр}, {адрес, регистр}
```
* Операция присваивания адреса lea (load effective address)

exit system call
```
movq $60, %rax
movq $100, %rdi
syscall
```


```
move {mark},{register}
move ({mark}),{register}

move ${mark},{register}
```

### Типичные конструкции ассемблерного кода
```
some_func:
  // Пролог
	pushq %rbp
	movq %rsp, %rbp
	...
	// Эпилог
	movq %rbp, %rsp
	popq %rbp
	ret
```

Пролог и эпилог встречаются практически в каждой подпрограмме. Поэтому для сокращения количества операций, а следовательно и размера кода,
вместо эпилога пишут просто `leave`:

```
// movq %rbp, %rsp
// popq %rbp
leave
```
Неплохо было бы иметь аналогичную операцию и для пролога, но чего нет, того нет.


```
some_func:
	pushq %rbp
	movq %rsp, %rbp
	...
	leave
	ret
``	



Как при использовании меток создавать "перемещаемые" (relocatable) программы? Разве метки не будут
"жестко" прописаны в объектных файлах? Предполагается, что ответ кроется в использовании относительной адресации.
TODO: Выяснить.


Метка &mdash; фактически просто число. Поэтому правила действия с ней такие же, как и с константами.
%%
movq label, %rax   # Загрузить значение из ячейки памяти с номером label в rax
movq $label, %rax  # Загрузить значение label в rax
%%

#|
||Загрузка в rax числа по адресу label и добавление его к себе же||
||
%%
movq label, %rax
addq label, %rax
%%
|
%%
movq (label), %rax
addq (label), %rax
%%
||
|#

%%
.data
num:
        .long    0x12345678
.text
main:
        movl (num), %eax
        addl (num), %eax
        ret
%%

* %%syscall%%. Аргументы в rdi, rsi, rdx, rcx, r8 and r9. Номер системного вызова указывается на rax. Результат будет также на rax. 
Регистры rcx и r11 не будут восстановлены.
* %%int $0x80%%.
* %%sysenter%%.
* %%vsyscall%%.
* %%vdso%%.

Как работает печать строки. Последний символ отбрасывается при печати?

1. Написать a.s, в которой будет неинициализированная глобальная переменная типа int, причем заполненная не нулями, а единицами. Из main.c распечатать эту переменную. Убедиться, что там действительно ненулевое значение.


Почему применяют xor вместо mov? Команда xor короче, а значит, занимает меньше места в процессорном кэше, меньше времени тратится на декодирование, и программа выполняется быстрее. Но эта команда устанавливает флаги. Поэтому, если вам нужно сохранить состояние флагов, применяйте mov

## Подпрограммы

* `int $0x80` &mdash; все аргументы через регистры
* `call` &mdash; все аргументы через стек
* `fastcall` &mdash; часть аргументов функции (первые N ???) передается через регистры и часть &mdash; через стек.
Экспериментально установлено, это первые регистры это `%rdi`, `%rsi`. 6 первых аргументов передаются через регистры RDI, RSI, RDX, RCX, R8, R9, а остальные — через
стек.

Ту же функцию, печатающую "Hello, world!" можно написать несколькими способами
```

```




`rcx` и `rdx` постоянно "срываются" при вызове функций.

Системные вызовы и функции

`call` меняет регистр %rcx. Что там лежит после вызова?

В Unix-системах x86-64 первые 6 аргументов передаются через регистры RDI, RSI, RDX, RCX, R8, R9, а остальные &mdash; через стек.

При записи в 

#### Использование `printf`
```
.globl main
.type main, @function

.data
printf_format:
	.string "%d\n"

.data
main:
	xor %rax, %rax // TODO: зачем нужно обнуление перед вызовом? Без него точно бывает Segmentation Fault
	movq $printf_format, %rdi
	movq (%rsp), %rsi // Предполагается, что последние 8 байт отведены под печатаемое число
	call printf
```


#### Использование `scanf`

* https://stackoverflow.com/questions/27095286/using-scanf-with-x86-gas-assembly

# Задачи
* Объявите инициализированный массив 
* Объявите массив `[1, 2, 3, 4, 5]`. Напишите функцию `double_array`, которая удваивает его. Затем выведите на печать полученный массив с помощью уже
написанной функции `print_array`
* Подсчитайте количество единичных битов в некотором числе `number`, распечатайте его.
```
.data
number:
	.long $0x...
.text
  ...

print_bits_number:
  ...
```

* Напишите рекурсивную версию factorial
* Напишите нерекурсивную версию factorial
* Напишиле 64-битную версию factorial


# Применение
Знание ассемблера и умение пользоваться отладчиком GDB являются хорошим подспорьем в TODO
* Исследовании кода
* Оптимизации
* Поиске ошибок

Анализ содержимого секции данных.
```
objdump -s -j .rodata a
```

```
readelf -x .rodata hello_world.o
```

ojbdump можно считать устаревшей утилитой и лучше пользоваться readelf <https://stackoverflow.com/questions/22160621/why-does-objdump-not-show-bss-shstratab-symtab-and-strtab-sections>

# Патчинг кода
{% highlight cpp %}
#include <stdio.h>

int main() {
	printf("Hello, world!");
	return 0;
}
{% endhighlight %}

```
$ gcc hello_world.c
```

#### String interning

Компилятор неплохо справляется с оптимизациями. В частности, допустим есть следующий код
{% highlight cpp %}
#include <stdio.h>

void PrintHelloWorld() {
  printf("Hello, world!\n");
}

void PrintWorld() {
  printf("world!\n");
}

int main() {
	PrintHelloWorld();
	PrintWorld();
	return 0;
}
{% endhighlight %}

Теперь скомпилируем с флагом `-O1` (c меньшим уровнем оптимизации эффект не проявляется, по крайней мере в `gcc`)
```
$ gcc string_interning.c -o a -O1
$ readelf -x .rodata a

Hex dump of section '.rodata':
  0x004005d0 01000200 48656c6c 6f2c2077 6f726c64 ....Hello, world
  0x004005e0 2100                                !.
```




## alloca

```
(gdb) set disassembly−flavor intel
(gdb) disas
```
