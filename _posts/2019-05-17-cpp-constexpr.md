---
layout: post
title: Флаги компиляции
author: siri3us
categories: C++
---

### Источники
* [2014-07-03] <https://habr.com/en/post/228181/>
* CppCon 2017 <span<"Practical C++17"<span> <https://www.youtube.com/watch?v=nnY4e4faNp0&t=33s>
* https://akrzemi1.wordpress.com/2013/06/20/constexpr-function-is-not-const/
* Спецификатор constexpr в C++11 и в C++14 <https://habr.com/en/post/228181/>
* https://gnzlbg.github.io/static_vector/

Спецификатор `constexpr` появился в C++11. 

Переменные, функции и объекты, которые могут быть рассчитаны на этапе компиляции.

В C++14 возможности `constexpr` функций были расширены, так что теперь это может быть многострочная функция


Тип `constexpr`-переменной должен быть литеральным типом

Ограничения на `constexpr`-функции:
* `constexpr`-функция не может быть виртуальной (virtual) [На данный момент
в C++20 есть предложение о возможности добавления таких функций].
* `constexpr`-функция должна возвращать LiteralType.


`constexpr`-функции и constexpr-конструкторы по умолчанию являются `inline`
([dcl.constexpr], §7.1.5/2 in the C++11 standard): "constexpr functions and constexpr constructors are implicitly inline (7.1.2)." 

## 



* **class type** объявляется с помощью ключевого слова __class__ или __struct__
* **union type** объявляется с помощью ключевого слова __union__
* **enumeration type** объявляется с помощью ключевого слова __enum__

Есть еще **union-like** классы. Что это такое?

С union-ами вообще запутанная история. 
Что будучи инициализированным, union нельзя менять активный тип. Но что же делать? А все просто: можно
просто поменять сам объект union-а

### constexpr-объекты
Работа с constexpr завист от типа


Стандарт налагает три весьма логичных требования на костанту времени компиляции, которые гарантируются, что
это константа может быть созадана на этапе компиляции:
* Константа имеет литеральный тип __LiteralType__. В большинстве случаев достаточно поставить себя на место
компилятора, чтобы понять, является ли данный тип литеральным или нет. Литеральные типы введены как характеристика того, может ли объект быть `constexpr`, т.е. тут непосредственная связь в терминологии:
	   * Если объект может быть создан на этапе компиляции, то он имеет литеральный тип.
	   * Если объект имеет литеральный тип, то он может быть создан на этапе компиляции.
* Константа должна быть тут же проинициализирована, причем инициализирующее выражение должно быть константным, т.е. __constant expression__ (ну а как иначе компилятору его оценить).

Джейсон Тернер в своем докладе constexpr ALL the Things приводит следующий "Huge list":
* `constexpr` конструктор
* `std::is_trivially_destructible`

Размеры должын быть известны на этапе компиляции. Это ограничение 
перестанет быть критичным, если появятся `constexpr`-аллокаторы


### constexpr-функции

* Можно пос. Тем не менее спецификатор `constexpr` требуется указать явно &mdash; по сути это указание компилятору "присмотреться" к данной функции и проверить, что с заданными аргументами она может быть
вычеслена в compile-time
* Не обязательно все пути исполнения должны быть возможны в `compile-time`. Например, может быть 
Таким образом, `constexpr`-функции могут иметь side effects.

### constexpr-методы

## if constexpr
```
if constexpr(/* constant expression */) {
  // if true, this block is compiled
} else {
	// if false, this block is compiled
}
```

### Новшества C++14
* В C++11 тип `void` не был литеральным, поэтому нельзя было написать `constexpr`-функцию, возвращающую `void`
* В С++11 `constexpr` в методах подразумевает `con st`. Само по себе это уже весьма сильное ограничение, которые фактически не позволяло комфортно работать с пользовательскими литеральными типами.
* В C++11 `constexpr` функци должны были быть однострочными.

### C++17
Какие классы по вашему мнению являются `constexp
* `std::array`
* `std::string`
* `std::string_view`
* `std::pair`
* `std::optional`
* `std::variant`
* `std::swap`

## assert в constexpr-функциях
Наши требования к assert-ам:
* В RELEASE моде не должно быть никаких накладных расходов, связанных с проверкой. C-шный `assert` этому требованию вполне себе удовлетворяет. Достаточно заглянуть в его типичную имплементацию в 
заголовочном файле `<cassert>`:
```
#ifdef NDEBUG
#define assert(condition) ((void)0)
#else
#define assert(condition) /*implementation defined*/
#endif
```
* Должен работать как в runtime-е, так и в compile time-е. 

## Конкатенация строк на этапе компиляции


# Задачи
Имплементруйте `constexpr`-аллокатор.
