---
layout: post
title: Линковка в C/C++. Статические и динамические библиотеки
author: siri3us
categories: C++
toc: true
---

# Статические и динамические библиотеки
Материалы, использованные при подготовке данной статьи:
* <https://www.lurklurk.org/linkers/linkers.html>
* <http://tldp.org/HOWTO/Program-Library-HOWTO/introduction.html>
* <https://amir.rachum.com/blog/2016/09/17/shared-libraries>

* Объявление символа
* Определение символа

В первую очередь объясним понятия определения и объявления символа. Символом может быть переменная или функция.


В случае переменных имеется два типа определений:
* global variables, which exist for the whole lifetime of the program ("static extent"), and which are usually accessible in lots of different functions
* local variables, which only exist while a particular function is being executed ("local extent") and are only accessible within that function


    A definition of a variable induces the compiler to reserve some space for that variable, and possibly fill that space with a particular value.
    A definition of a function induces the compiler to generate code for that function.


Зачастую эти два действия совмещены

`static` &mdash; одно из самых нагруженных слов в `C`, и уж тем более в `C++`
* Ключевое слово `static`, примененное к символу в глобальной области видимости, сужает область видимости данного символа до единицы трансляции.
* Ключевое слово `static`, примененное к определению локальной переменной, делает время ее жизни глобальным.

{% highlight cpp %}
// Uninitialized global variable
int x_global_uninit;

// Initialized global variable
int x_global_init = 1;

// Uninitialized global variable with local scope
static int y_global_uninit;

// Initialized global variable with local scope
static int y_global_init = 2;

// Declaration of a global variable
extern int z_global;

int fn_a(int x, int y);

static int fn_b(int x) {
  return x + 1;
}

int fn_c(int x_local) {
  int y_local_uninit;
  int y_local_init = 3;
  x_global_uninit = fn_a(x_local, x_global_init);
  y_local_uninit = fn_a(x_global_uninit, y_local_init);
  y_local_uninit += fn_b(z_global);
  return y_global_uninit + y_local_uninit;
}
{% endhighlight %}

{% highlight cpp %}
#include <cstdio>
// Initialized global variable (promise to symbols.cpp)
int z_global = 4;

static int y_global_init = 5;

extern int x_global_init;

int fn_a(int x, int y) {
  return x + y;
}

int fn_c(int x_local);

int main() {
  const char *message = "Hello, world!";
  int x_local = fn_a(6, 7);
  int result = fn_c(x_local + y_global_init);
  printf("Result of f_c(%d) = %d\n", x_local, result);
  return 0;
}
{% endhighlight %}

```
$ nm -S symbols.o
0000000000000068 000000000000001b T main
0000000000000000 0000000000000004 D x_global_init
0000000000000000 0000000000000004 B x_global_uninit
                 U _Z4fn_aii
000000000000000f 0000000000000059 T _Z4fn_ci
                 U z_global
0000000000000004 0000000000000004 d _ZL13y_global_init
0000000000000004 0000000000000004 b _ZL15y_global_uninit
0000000000000000 000000000000000f t _ZL4fn_bi
```

* `T` функция с глобальной видимостью
* `t` функция с локальной видимостью
* `D` иницилизированная переменная с глобальным временем жизни и глобальной видимостью
* `d` иницилизированная переменная с глобальным временем жизни и локальной видимостью
* `B` неинициализированная переменная с глобальным временем жизни и глобальной видимостью
* `b` неиницилизированная переменная с глобальным временем жизни и локальной видимостью
* `U` неразрешенное имя

```
$ nm -S main.o
0000000000000014 0000000000000055 T main
                 U printf
0000000000000000 0000000000000014 T _Z4fn_aii
                 U _Z4fn_ci
0000000000000000 0000000000000004 D z_global
0000000000000004 0000000000000004 d _ZL13y_global_init
```

Видно, что `main.o` требует извне символы `printf` и определение функции `fn_(int, int)`

Можно убедиться, что после линковки в исполняемый файл `main`, в последнем все символы разрешены:
```
$ nm -S main
0000000000601048 B __bss_start
0000000000601048 0000000000000001 b completed.7631
0000000000601028 D __data_start
0000000000601028 W data_start
0000000000400460 t deregister_tm_clones
00000000004004d0 t __do_global_dtors_aux
0000000000600e20 t __do_global_dtors_aux_fini_array_entry
0000000000601030 D __dso_handle
0000000000600e28 d _DYNAMIC
0000000000601048 D _edata
0000000000601058 B _end
0000000000400654 T _fini
0000000000400500 t frame_dummy
0000000000600e18 t __frame_dummy_init_array_entry
0000000000400828 r __FRAME_END__
0000000000601000 d _GLOBAL_OFFSET_TABLE_
                 w __gmon_start__
000000000040068c r __GNU_EH_FRAME_HDR
00000000004003c8 T _init
0000000000600e20 t __init_array_end
0000000000600e18 t __init_array_start
0000000000400660 0000000000000004 R _IO_stdin_used
                 w _ITM_deregisterTMCloneTable
                 w _ITM_registerTMCloneTable
0000000000400650 0000000000000002 T __libc_csu_fini
00000000004005e0 0000000000000065 T __libc_csu_init
                 U __libc_start_main@@GLIBC_2.2.5
000000000040051b 0000000000000055 T main
                 U printf@@GLIBC_2.2.5
0000000000400490 t register_tm_clones
0000000000400430 000000000000002a T _start
0000000000601048 D __TMC_END__
0000000000601040 0000000000000004 D x_global_init
000000000060104c 0000000000000004 B x_global_uninit
0000000000400507 0000000000000014 T _Z4fn_aii
000000000040057f 000000000000005c T _Z4fn_ci
0000000000601038 0000000000000004 D z_global
000000000060103c 0000000000000004 d _ZL13y_global_init
0000000000601044 0000000000000004 d _ZL13y_global_init
0000000000601050 0000000000000004 b _ZL15y_global_uninit
0000000000400570 000000000000000f t _ZL4fn_bi
```
Здесь также появилось много новых символов, связанных с тем, что `main` &mdash; это исполняемый файл.

### One definition rule

* Некоторые функции компилятор может делать `inline`. Верно ли, что в файлах, в которых определение функции доступно изначально, она будет заинлайнена, а
в тех, что линкуются к данному файлу, может быть не-`inline`. Что будет, если функция определена в заголовочном файле?

Неинициализированные глобальные переменные и `-fno-common` опция компилятора/линковщика

#### Вопросы
* Что будет, если при инициализации нетривального глобального объекта бросается исключение? Будет ли оно замечно хоть где-то?
* Что будет, если при инициализации статической локальной переменной бросается исключение? Может ли быть так, что статическая локальная переменная создается в блоке инициализации,
а не при первом входе в функцию? Если статическая локальная переменная создается условно, то когда она создается?
* Линковка к статической библиотеке, в одном из объектных файлов которой есть статическая переменная



**Библиотека** &mdash; бинарный файл, содержащий код и данные. Читатель может спросить, в чем отличие библиотеки от **исполняемого файла**: Ведь исполняемый файл &mdash; это тоже бинарный файло, содержащим код и данные. Отличине заключается в том, что исполняемый файл содержит **точку входа**, используемой операционной системой для старта выполнения программы. Для начала можно считать, что этой точкой входа является функция `int main(int argc, char** argv, char **envp)`, с которой знакомы все программисты C/C++.

Библиотеки бывают нескольких видов:
* статические библиотеки (static libraries) &mdash; код из этих библиотек фактически помещается в компилируемый файл (static libraries are linked into a compiled file or executable).
* динамические библиотеки (shared libraries, dynamic libraries) &mdash; загружаются во время старта программы (shared libraries are loaded by executable)
* динамически загружаемые библиотеки (dynamically loaded libraries, DLLs) &mdash; загружаются во время работы программы, а не при ее старте.

**Примечание.** В Windows динамические библиотеки имеют расширение `.DLL`, а в Unix-е &mdash; `.so`. В обоих системах разделение на динамические библиотеки (shared libraries) и динамически загружаемые библиотеки (DLLs) по сути условно: на самом деле один и тот же `.so`- или `.DLL`-файл, отличается лишь сценарий использования.

Когда говорят о "DLL-библиотеке", не совсем понятно, имеется ли ввиду динамическая библиотека в Windows (с расширением `.DLL`) или же загружаемая на этапе исполнения динамическая библиотека. Потому данный термин использовать не будем &mdash; вместо него везде будем использовать понятие **динамической библиотеки** (shared library).

Важно понимать, что 

* Relocatable object file &mdash; Contains code and data in a form that can be combined with other relocatable object files to form executable object file. Each .o file is produced from one or serveral source (.c,.cpp) file(s).
* Executable object file &mdash; Contains code and data in a form that can be copied directly into memory and then executed.
* Shared object file &mdash; Special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run-time. Called Dynamic Link Libraries (DLLs) by Windows.


Релоцируемые объекты, исполняемые файлы, динамические библиотеки &mdash; все это бинарные файлы, которые следуют одному и тому же стандартизованному формату &mdash; **Executable and Linking Format (ELF)**.

Plugin Authentication Module (PAM) system 

# Статические библиотеки
* <http://tldp.org/HOWTO/Program-Library-HOWTO/introduction.html>


Для начала поговорим о статических библиотеках, так как это самый простой тип библиотек.
Также исторически статические библиотеки появились раньше.
По существу статические библиотеки не многим отличаются от объектных `.o` файлов.

* В UNIX-системах для создания статических библиотек используется утилита `ar`, а создаваемая ей библиотека имеет расширение `.a`.


These library files are normally also prefixed with "lib" and passed to the linker with a "-l" option followed by the name of the library, without prefix or extension (so "-lfred" will pick up "libfred.a"). 
* В Windows статические библиотеки имеют расширение `.LIB` и создаются утилитой `LIB`. На самом деле это не самое удачное расширение, так как точно
такое же используется в динамических `DLL`-библиотеках для списка символов, доступных в `DLL`-файлах.



### Создание статической библиотеки
Статическая библиотека &mdash; это просто архив из нескольких объектных файлов.

!Внимание! Крайне важно, что выше библиотека libctest.a указана после main.cpp. Например следующая команда завершится ошибкой
```
$ g++ main.cpp libctest.a -o main
/tmp/ccLKV5AA.o: In function `main':
main.cpp:(.text+0x1f): undefined reference to `ctest1(int*)'
main.cpp:(.text+0x3f): undefined reference to `ctest2(int*)'
collect2: error: ld returned 1 exit status
```
Это связано с тем, что каждая последующая библиотека используется, только если она предоставляет неизвестные символы.


```
ar -rcs libctest.a ctest1.o ctest2.o
```

```
$ g++ main.cpp -o main -L. -lctest
$ g++ main.cpp -o main libctest.a
```

```
$ g++ -c logger.cpp -o logger.o
$ g++ -c geom.cpp -o geom.o
$ ar rvs libgeom.a geom.o logger.o
```



#### Циклические зависимости между объектными файлами в статической библиотеке
* Циклические зависимости между разными .o файлами в одной библиотеке
* Циклические зависимости между .o файлами разных библиотек

## Динамические библиотеки

В отличие от статических библиотек, код из которых буквально копируется в исполняемый файл, динамические библиотеки загружаеются на старте программы или этапе выполнения (оба случая будут разобраны ниже). Именно по последнему признаку происходит деление динамических библиотек на два типа:
* dynamic (shared) library
* dynamically loaded library

В остальном динамические и динамически загружаемые библиотеки &mdash; суть один и те же .so файлы.

* Загрузка библиотек на старте программы (происходит до вызова main());
* Загрузка библиотек на этапе исполнения в спомощью dlopen/dlsym/dlclose

### Создание динамической библиотеки

#### Пробная библиотека random
{% highlight cpp %}
// Содержимое random.h
unsigned int get_random_number();
{% endhighlight %}

{% highlight cpp %}
// Содержимое random.cpp
unsigned int _seed;

unsigned int get_random_number() {
	_seed = (_seed + 1) * 123456789u;
	return _seed;
}
{% endhighlight %}

{% highlight cpp %}
// Содержимое main.cpp
#include <iostream>
#include "random.h" // Здесь обещаем, что требуемая функция существует

int main() {
	std::cout << get_random_number() << std::endl;
	return 0;
}
{% endhighlight %}

Под `c++` может быть gcc, clang, msvc. В общем, любой компилятор.
```
$ c++ -c random.cpp -o random.o          # Компиляция объектоного файла
$ c++ -shared random.o -o librandom.so   # Создание библиотеки
```
Для того, чтобы система могла найти библиотеку `random`, соответствующий ей `.so` файл должен
быть называн в соответствии с правилами системы: в нашем случае `lib<name>.so`.
Иначе библиотека попросту не будет найдена во время линковки.

```
$ c++ main.cpp -o main
/tmp/main-cf1cee.o: In function `main':
main.cpp:(.text+0x10): undefined reference to `get_random_number()'
clang: error: linker command failed with exit code 1 (use -v to see invocation)
```
Получим ошибку компиляции, говорящую о том, что библиотека `librandom.so` не найдена.

### readelf

* `readelf -h main` &mdash; прочитать ELF-заголовок
* `readelf -l main` &mdash; прочитать сегменты

```
$ readelf -l main

Elf file type is EXEC (Executable file)
Entry point 0x400890
There are 9 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                 0x00000000000001f8 0x00000000000001f8  R E    8
  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238
                 0x000000000000001c 0x000000000000001c  R      1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x0000000000000bbc 0x0000000000000bbc  R E    200000
  LOAD           0x0000000000000dd0 0x0000000000600dd0 0x0000000000600dd0
                 0x0000000000000298 0x00000000000003c8  RW     200000
  DYNAMIC        0x0000000000000de8 0x0000000000600de8 0x0000000000600de8
                 0x0000000000000210 0x0000000000000210  RW     8
  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_EH_FRAME   0x0000000000000a44 0x0000000000400a44 0x0000000000400a44
                 0x0000000000000044 0x0000000000000044  R      4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     10
  GNU_RELRO      0x0000000000000dd0 0x0000000000600dd0 0x0000000000600dd0
                 0x0000000000000230 0x0000000000000230  R      1

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 
   03     .init_array .fini_array .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag .note.gnu.build-id 
   06     .eh_frame_hdr 
   07     
   08     .init_array .fini_array .dynamic .got
```
* `readelf -S main` &mdash; прочитать секции

```
$ readelf -S main
There are 30 section headers, starting at offset 0x1bd8:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400238  00000238
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             0000000000400254  00000254
       0000000000000020  0000000000000000   A       0     0     4
  [..]

  [21] .dynamic          DYNAMIC          0000000000600de8  00000de8
       0000000000000210  0000000000000010  WA       6     0     8

  [..]

  [28] .symtab           SYMTAB           0000000000000000  000010e0
       00000000000006d8  0000000000000018          29    47     8
  [29] .strtab           STRTAB           0000000000000000  000017b8
       0000000000000319  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
```

В Program Header Table ELF файлы могут содержать (динамические библиотеки обязтельно содержат)
segment header, описывающий сегмент `PT_DYNAMIC`. Этот сегмент содержит секцию
`.dynamic`, который в свою очередь содержит информацию о динамических зависимостях файла.


#### Direct Dependencies
Теперь используем утилиту `readelf` для более детального анализа секции `.dynamic` нашего
исполняемого файла. В частности, данная секция содержит все динамические зависимости нашего ELF-файла.
Поэтому априоре мы ожидаем увидеть там только `librandom.so`, однако...

```
$ readelf -d main | grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [librandom.so]
 0x0000000000000001 (NEEDED)             Shared library: [libstdc++.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libm.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
```

We can see `librandom.so`, which we specified, but we also get four extra dependencies we didn’t expect. These dependencies seem to appear in all compiled shared libraries. What are they?
* libstdc++: The standard C++ library.
* libm: A library that contains basic math functions.
* libgcc_s: The GCC (GNU Compiler Collection) runtime library.
* libc: The C library: the library which defines the ‘system calls’ and other basic facilities such as open, malloc, printf, exit, etc.

Okay &mdash; so we know that main knows it depends on librandom.so. So why can’t main find librandom.so in runtime?

#### Пробная библиотека geom
```
$ c++ -fpic -shared geom.cpp -o libgeom.so
```

Компиляция динамической библиотеки
```
$ g++ -fpic -shared geom.cpp -o libgeom.so
```


* shared object name (soname): `libgeom.so.1`, `/usr/lib/libreadline.so.3` &mdash; fully qualified soname
* real name: `libgeom.so.1.0.5`, `/usr/lib/libreadline.so.3.0.` real name, to which the `ldconfig` will create symbolic link
* linker name: `libgeom.so`, `/usr/lib/libreadline.so`


* /lib системные, требуемые при старте
* /usr/lib системные, требуемые для работы
* /usr/local/lib пользовательские

Указание пути к библиотеке при линковке
* LD_LIBRARY_PATH

Указание пути к библиотеке на старте
* `/lib/ld-linux.so.2 --library-path PATH EXECUTABLE`

* В чем разница между `-fPIC` и `-fpic`
* -Wl,export-dynamic или -rdynamic

Все зависимости динамической библиотеки 
```
$ ldd name-of-libraray/name-of-executable
```

### Поиск динамической библиотеки
* Поиск при линковке 
* Поиск при загрузке

Порядок поиска динамической библиотеки на старте программы:
1. Directories listed in the executable’s `rpath`.
2. Directories in the `LD_LIBRARY_PATH` environment variable, which contains colon-separated list of directories (e.g., `/path/to/libdir:/another/path`)
3. Directories listed in the executable’s `runpath`.
4. The list of directories in the file `/etc/ld.so.conf`. This file can include other files, but it is basically a list of directories - one per line.
5. Default system libraries - usually `/lib` and `/usr/lib` (skipped if compiled with `-z nodefaultlib`).

Здесь линкеру лишь фажно убедиться, что динамическая библиотека предоставляет нужные символы. Это значит, что библиотеку можно **подменить**, т.е. на этапе линковки и запуска использовать разные библиотеки.

* `export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH`
* `export LD_LIBRARY_PATH=/path/to/lib:$LD_LIBRARY_PATH`
* `export LD_LIBRARY_PATH=\`pwd\`:$LD_LIBRARY_PATH`

Можно "встроить" путь на этапе линковки
```
$ c++ -fpic -shared geom.cpp -o libgeom.so -Wl,-rpath,#RELATIVE_PATH_HERE
```


### Использование динамических библиотек
* `readelf -h main` &mdash; просмотреть общую информацию
* `readelf -l main` &mdash; просмотреть сегменты
* `readelf -S main` &mdash; просмотреть секции
* `readelf -d main` &mdash; прочитать `.dynamic` секцию, посмотреть на `direct dependencies`

```
$ readelf -h main
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x4005e0
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4584 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 27
```

#### Динамические библиотеки в Windows (DLLs)
The most major difference between the two is that symbols are not automatically exported by Windows libraries. On Unix, all of the symbols from all of the object files that were linked into the shared library are visible to users of the library. On Windows, the programmer has to explicitly choose to make particular symbols visible—i.e. to export them. 

There are three ways to export a symbol from a Windows DLL (and all three ways can be mixed together in the same library).
* In the source code, declare the symbol as `__declspec(dllexport)`, thusly:
```
    __declspec(dllexport) int my_exported_function(int x, double y);
```
* On the invocation of the linker, use the `/export:symbol_to_export` option to `LINK.EXE`.
```
    LINK.EXE /dll /export:my_exported_function
```
* Get the linker to pull in a module definition (.DEF) file (by using the /DEF:def_file linker option), and in that file include an EXPORTS section that contains the symbols you want to export. 
```
EXPORTS
  my_exported_function
  my_other_exported_function
```
Once C++ is added in to the mix, the first of these options is the easiest because the compiler takes care of the name mangling for you. 

## C++
Весь код выше неявно компилировался C++ компилятором. Однако на самом деле язык C++ внес массу нововведений, осложняющих если и не вычислительную сложность процедуры линковки, то уж точно ее логику.

### Использование C библиотек в C++ коде
Из-за иного именования символов будут ошибки линковки при попытке слиновать исполняемый файл к C-библиотеке.
Чтобы этого не было, следует обернуть все C-объявления в блок `extern "C" { ... }`. В таком случае ко всем
объявлениям внутри блока будут применяться правила именования C. Правда все равно следует учитывать, что компиляция должна происходить с помощью одного компилятора (gcc и C++, clang и clang++ и т.п.).

### Вопросы и задачи
* Пусть в нас в системе несколько програм использующих одну динамическую библиотеку. Пусть в этой библиотеке есть глобальный счетчик вызова некоторой функции. Верно ли, что находясь в одном из процессов мы можем наблюдать увеличение этого счетчика?
* Как заставить загрузиться динамическую библиотеку, в которой запускаются конструкторы статических объектов, используемых далее в исполняемом файле?
* Как происходит разрешение символов, когда .h файла с определением класса грузится во множество .cpp файлов. Что происходит с функциями по умолчанию?

# Линковка
Пусть есть исходних main.cpp исполняемого файла main и две библиотеки: mymath (mymath.h, mymath.cpp) и geom (geom.h, geom.cpp). Рассмотрим различные варианты взаимоотноешния между этими библиотеками и исполняемым файлом. Будем разделять **отношение линковки** и **отношение использования**:
* **`libA.so` линкуется к `libB.so`**, если в зависимостях при линковке явно указана библиотека `libB.so`.
* **`libA.so` использует `libB.so`**, если поведение `libA.so` использует символы из `libB.so`.

Порядок указания файлов при линковке
* Object files
* Archive libraries
* Shared libraries

При линковке  библиотеки/исполняемого файла компилятор проверяет, что найдены и разрешены все символы. По умолчанию данное поведение включено только для исполняемых файлов. Библиотеки же могут быть слинкованы без разрешения (резолюции) всех символов (за ответственны флаги `-Wl,--no-undefined`, которые рассматриваются далее).


### Источники
* <https://flameeyes.blog/2008/11/19/relationship-between-as-needed-and-no-undefined-part-1-what-do-they-do>
* <https://flameeyes.blog/2008/11/20/misguided-link-and-as-needed>
* <http://wiki.rosalab.ru/ru/index.php/Underlinking>

* Порядок разрешения символов при линковке объектных файлов (формирующих исполняемый файл) к статическим библиотекам
* Порядок разршенеия символов при линковке объектных файлов (формирующих исполняемый файл) к динамическим библиотекам
* Указание пути к требуемым динамическим библиотекам во время линковки

## Underlinking. Флаги `--as-needed` и `--no-undefined`

Существует множество флагов, влияющих на процесс линковки. Сейчас рассмотрим несколько из них
* `-Wl,--no-undefined`
* `-Wl,--as-needed`
* `-Wl,--no-as-needed`


* `main.cpp` 
* `libgeom.h`, `libgeom.cpp`
* `libgeom_impl.h`, `libgeom_impl.cpp`

### Отдельная линковка всех составляющих
```
$ LD_LIBRARY_PATH=`(pwd)`
$ g++ -fpic -shared geom.cpp -o libgeom.so
$ g++ -fpic -shared geom_impl.cpp -o libgeom_impl.so
$ g++ -c main.cpp -o main
```
Полезно посмотреть на то, что получилось:
```
$ ldd libgeom_impl.so          # statically linked (нет динамических зависимостей)
$ readelf -d libgeom_impl.so   # Нет NEEDED блоков
$ nm -S libgeom.so             # Нет U-символов
$ ldd libgeom_impl.so          # statically linked
$ readelf -d libgeom_impl.so   # Нет NEEDED блоков
$ nm -S libgeom_impl.so        # Есть U-символы, которые на самом деле предоставляются библиотекой libgeom_impl.so
```


GNU-линковщик по умолчанию использует флаг `-Wl,--as-needed`, поэтому процедура линковки завершится с ошибкой
```
$ g++ main.o -o main [-Wl,--as-needed] -L. -lgeom_impl -lgeom
```
Проблема в том, что `main.o` содержит U-символы, которые предоставляет библиотека libgeom.so, но не libgeom_impl.so, поэтому
последняя попросту игнорируется. Однако все успешно линкуется, если поменять порядок библиотек:
```
$ g++ main.o -o main [-Wl,--as-needed] -L. -lgeom -lgeom_impl
```
Теперь при обработке символов из libgeom.so линковщик увидит, что есть неразрешенные символы и будет пытаться найти их дальше.

Можно было бы также исправить проблему линковки с помощью флага `-Wl,--no-as-needed`. В таком случае линковщик будет обрабатывать все
библиотеки независимо от того, содержат ли они символы из текущего undefined-фронта или нет.
```
$ g++ main.o -o main -Wl,--no-as-needed -L. -lgeom_impl -lgeom
```
Флаг линковщика `-Wl,--no-as-needed` должен быть перед линкуемой библиотекой, чтобы последняя не исключалась из списка зависимостей, если создаваемая библиотека или исполняемый файл не обращаются к ее символам.


```
$ readelf -d main
...
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libgeom.so]
 0x0000000000000001 (NEEDED)             Shared library: [libgeom_impl.so]
 0x0000000000000001 (NEEDED)             Shared library: [libstdc++.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...

$ ldd main
        linux-vdso.so.1 =>  (0x00007ffd74ac1000)
        libgeom.so => not found
        libgeom_impl.so => not found
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f2095b4e000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2095784000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f209547b000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f2095eda000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f2095263000)
```

### Линкуем geom к geom_impl заранее
```
$ LD_LIBRARY_PATH=`(pwd)`
$ g++ -fpic -shared geom.cpp -o libgeom.so
$ g++ -fpic -shared geom_impl.cpp -o libgeom_impl.so
$ g++ -c main.cpp -o main
```
Библиотека libgeom_impl.so никак не изменилась, поэтому здесь наблюдаем ту же самую картину:
```
$ ldd libgeom_impl.so          # Нет динамических зависимостей
        statically linked 
$ readelf -d libgeom_impl.so   # Нет NEEDED блоков
$ nm -S libgeom_impl.so             # Нет U-символов
```
А вот с библиотекой libgeom.so дела обстоят совсем иным образом:
```
$ ldd libgeom.so          # А вот теперь есть динамические зависимости
        linux-vdso.so.1 =>  (0x00007ffee6f71000)
        libmygeom_impl.so => ./libgeom_impl.so (0x00007f6514910000)  
$ readelf -d libgeom.so   # Теперь есть NEEDED блок
...
 0x0000000000000001 (NEEDED)             Shared library: [libgeom_impl.so]
...
$ nm -S libgeom.so        # Все также U-символы, которые на самом деле предоставляются библиотекой libgeom_impl.so
```

И вот теперь все слинкуется как надо:
```
$ g++ main.o -o main -L. -lgeom
./main
```

Однако надо помнить, что два способа отнюдь не эквиваленты: если раньше зависмость от `ligeom_impl.so` была прописана
в исполняемом файле `main`, то теперь

зависимость от библиотеки  будет в итоге прописана
в разных местах
```
$ readelf -d main | grep NEEDED
...
 0x0000000000000001 (NEEDED)             Shared library: [libgeom.so]
 0x0000000000000001 (NEEDED)             Shared library: [libstdc++.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
...

$ ldd main
        linux-vdso.so.1 =>  (0x00007fffc13c0000)
        libgeom.so => not found
        libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f05427a4000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f05423da000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f05420d1000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f0542b30000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f0541eb9000)
$ readelf -d libgeom.so | grep NEEDED
 0x0000000000000001 (NEEDED)             Shared library: [libgeom_impl.so]
$ ldd libgeom.so
        linux-vdso.so.1 =>  (0x00007ffc14591000)
        libgeom_impl.so => ./libgeom_impl.so (0x00007f0c9eaf7000)

```

* `-Wl,--no-undefined` По умолчанию типичное поведение ликовщика таково, что он использует данный флаг при линковки конечного исполняемого файла, но по ряду причин не делает того же самого при линковке динамических
библиотек [TODO: А что со статическими?]
* `-Wl,--as-needed`
* `-Wl,--no-as-needed`

Проблема. Линковщик по умолчанию прилинковывает все, что его просишь. При этом он не задумывается о том, используется ли код из библиотек, к которым происходит линковка.

* Использование `-Wl,--as-needed` не позволяет слинковаться, если какая-то динамическая библиотека A использует символы из другой динамической библиотеки B, к которой библиотека A не линкуется напрямую.
* `-Wl,--as-needed` приводит к тому, что при линковке оказывает влияние порядок передчисления динамических библиотек:


Объектные файлы перед списком библиотек используют полносвязное разрешение символов: проверяются все символы, доступные в каждом из объектных файлов.
А вот далее при просмотре списка библиотек, к которым происходит линковка, логика обработка может быть немного иной.


По умолчанию используется флаг -Wl,--as-needed. В таком случае перечисленные в списке линковки библиотеки просматриваются в порядке слева направо. Формируется список разрешенных и неразрешенных символов. Происходит попытка разрешить зависимости.

Если используется флаг -Wl,--as-needed, библиотеки, которые не содержат напрямую исползуемых символов, не рассматриваюттся.


* Что будет, если в списке линковки есть библиотека, которая содержит символы, которые не получается разрешить с использованием текущих библиотек, но при этом сама библиотека содержит используемые символы? Сама библиотека фактически не нужна (просто попала в список как "мусор")?
* Что будет, если одна из библиотек требует символ из компилируемого файла?

**Underlinking** states for the situation when a binary uses a symbol not provided by libraries it is directly linked to. For example, libeb uses "deflate" from `zlib`. But `-lz` is not passed during build. This is allowed for shared libraries.

Типичный пример underlinking-а в C/C++, это линковка приложения к библиотеке `libpthread.so`. Рассмотрим, например, некоторую программу, использующую
заголовочный файл `thread`:
{% highlight cpp %}
#include<iostream>
#include<thread>

int main() {
	...
	return 0;
}
{% endhighlight %}
Попытка слиновать исполняемый файл приведет к проблеме
```
$ g++ main.cpp -o main -std=c++14
/tmp/cccHTbB4.o: In function `std::thread::thread<main::{lambda()#2}&>(main::{lambda()#2}&)':
main.cpp:(.text+0x29e): undefined reference to `pthread_create'
collect2: error: ld returned 1 exit status
```
Правильный способ состоит в дополнительной линковке `libpthread.so`:
```
$ g++ main.cpp -o main -std=c++14 -lpthread
```



[TODO: Предположительно есть влияние порядка, если main использует библиотеку A, а libA.so использует libB.so, то в случае
```
$ c++ main.o -o main -Wl,--as-needed -lA -lB
```
будет сначала рассмотрена libA.so, у которой нет части символов, а потому будет также обработана и libB.so.
Т.е. в этом случае все будет хорошо. Но вот в случае
```
$ c++ main.o -o main -Wl,--as-needed -lA -lB
```
будут проблемы.

При этом надо понимать, что сама libA.so должна быть скомпилирована без --no-undefined, иначе вообще будет ошибка.
]


# Загрузка динамических библиотек через dlopen/dlsym/dlclose
Динамические библиотеки могут быть загружены на этапе выполнения с помощь специального API. Заметим, что здесь есть некоторые особенности, которые стоит рассмотреть.



### Что происходит во время загрузки библиотеки
Независимо от того, грузится ли библиотека на старте или этапе выполнения, происходит вызов определенных функций инициализации:
Во время загрузки запускается функция инициализации библиотеки, ...
{% highlight cpp %}
void __attribute__ ((constructor)) my_init(void);
void __attribute__ ((destructor)) my_fini(void);
{% endhighlight %}

%%-rdynamic%% компиляция с этим флагом приводит к тому, что при загрузке библиотеки через dlopen ей будут экспортированы символы из исполняемого файла. Это нужно, когда библиотека предполагает, что в исполняемом файле определены некоторые функции. RTLD_NOW проверяет определение всех символов, т.е. будут вызваны конструкторы всех глобальных объектов загружаемой библиотеки.
<{Пример

}>

%%nm libgeom.so%%

%%nm -l libgeom.so%%

Можно установить библиотеку в директорию %%/usr/lib%% или %%/usr/local/lib%%

* Как загрузить функцию из динамической библиотеки с помощью dlopen/dlsym/dlclose, если эта функция зависит от другой динамической библиотеки.
* Как загрузить класс из динамической библиотеки

#### Загрузка C++ класса из динамической библиотеки



### Неиспользуемые библиотеки и `-Wl,--as-needed`
Может быть так, что выполняемый файл main линкуется к библиотеке libA.so, но не использует ее. В таком случае линковщик по умолчанию создат выполняемый файл main без зависимости от libA.so. В целом данное поведение обоснованно в большинстве случаев. Однако бывают случаи, когда требуется некоторое поведение, которые происходит при загрузке динамической библиотеки, например, логгирование запуска на старте с помощью глобального объекта.

* Листинг для main.cpp
{% highlight cpp %}
#include <iostream>
int main() {
   std::cout << "This is the main program" << std::endl;
   return 0;
}
{% endhighlight %}

* Листинг для logger.cpp
{% highlight cpp %}
#include <iostream>

class Logger {
public:
  Logger() { std::cout << "This is a Logger's Ctor" << std::endl; }
};

Logger gLogger;
{% endhighlight %}

```
$ g++ -fPIC -shared logger.cpp -o liblogger.so
$ g++ main.cpp -o main -llogger -L. -Wl,-rpath,.
```

```
$./main
This is the main program
```

И действительно, вывод %%readelf -d | grep NEEDED%% показывает, что библиотеки liblogger.so нет в списке зависимостей, т.е. она не загружается и нет создания глобального объекта gLogger.

Ситуацию можно поправить опцией %%--no-as-needed%%, переданной линковщику
%%
$ g++ -fPIC -shared logger.cpp -o liblogger.so
$ g++ main.cpp -o main -Wl,--no-as-needed -llogger -L. -Wl,-rpath,.
%%
Теперь получаем следующий вывод.
%%
$ ./main
This is a Logger's Ctor
This is the main program
%%

=== -z defs
* Использование -z defs для библиотек позволяет находить ошибки разрешения символов прежде, чем в конечном счете происходит линковка исполняемого файла, т.е. просто экономить время на поиск ошибок
* Неиспользование -z defs позволяет создавать библиотеки, к которым можно будет прилинковывать различные версии других библиотек уже при линковке исполняемого файла.

Однозначного решения нет. Использование -z defs по умолчанию гарантирует максимальный уровень безопасности: любой исполняемый файл все равно должен будет разрешить все свои зависимости.

Иными словами библиотека geom &math; это backend для mymath

=== Отладка и исследование процедуры загрузки библиотек на старте
Для отладки линковки можно воспользовать переменной окружения LD_DEBUG:
%%
$ LD_DEBUG=files ./main
%%
Порядок загрузки соответствует порядку, в котором была указана линковка
Инициализация происходит в порядке загрузки. Финализация &mdash; в обратном порядке.

Узнать, какой символ к какой библиотеке линкуется можно командой
%%
$ LD_DEBUG=bindings ./main
%%
Кроме того, можно вообще исследовать весь стек вызовов с помощью %%strace%%
%%
$ strace -T ./main
%%
С помощью последней команды можно увидеть, что загрузка динамической библиотеки на старте требует вызовов open(), read(), mmap(), stat(), close()

**Процедура релокации (relocation process)** &mdash; нахождение определений U-символов.

Как можно ускорить загрузку?
* 
*
*

Увидеть список прямых зависимостей можно командой
%%
readelf -d #shared-or-executable
%%
Все зависимости можно посмотреть следующей командой (проходится рекурсивно по всем динамическим библиотекам):
%%
ldd #shared-or-executable
%%

* %%LDFLAGS="-Wl,--as-needed"%%
* %%gcc -Wl,--as-needed someunit1.o someunit2.o -lm -o program%% (!!Некорректно!! %%gcc -Wl,--as-needed -lm someunit1.o someunit2.o -o program%%)

=== Влияние порядка библиотек в линковке

Когда встречается первый файл/библиотека в списке, формируется список неизвестных символов. Когда впоследствии обрабатывается 

Таким образом следующие команды компиляции и линковки дадут разные результаты
%%
g++ main.cpp -o main -l1 -l2 -Wl,-rpath,.
%%
и
%%
g++ main.cpp -o main -l2 -l1 -Wl,-rpath,.
%%
Дадут разные результаты

* **То, что использует A, должно быть помещено перед A.** В таком случае таблица символов на разрешение пополниться символами, которые не разрешены для A.




Статические библиотеки

#### Циклические зависимости

* Циклические зависимости &mdash; это плохо
* Символы-дубликаты &mdash; это плохо

#### Порядок инициализации при динамической линковке
* Если файлов с определениями одного и того же символа несколько, то линковщик делает выбор в пользу одного из определений. Типичная ситуация &mdash; заголовочный h-файл с определением класса, в котором также определены все или некоторые из методов (включая, например конструктор и деструктор). **Как в этом случае происходит выбор?**



Ключевое значение имеет порядок аргументов при линковке. Этот порядок можно увидеть, вызвав следующую команду:
%%
objdump -p libgeom.so | grep NEEDED
%%

* https://www.oracle.com/technetwork/articles/servers-storage-dev/linkinglibraries6-429239.html
* https://www.oracle.com/technetwork/articles/servers-storage-dev/linkinglibraries7-430159.html

* -ffunction-sections
* -fdata-sections
* --unused-section

Увидеть все требуемые динамические библиотеки и пути к ним можно с помощью команды:
```
readelf -d main
objdump -p main | grep NEEDED
ldd -d libgeom.so # Показать 1) к каким библиотеками линкуется и 2) неразрешенные символы 
```

* https://www.oracle.com/technetwork/articles/servers-storage-dev/linkinglibraries4-405107.html

Что такое relocatable оъект?
* https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter2-55859/index.html
* https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter2-93321/index.html

=== Underlying linking (underlinking)
* %%-Wl,-z,defs%% &mdash; detect and reject underlinking
* %%-Wl,-z,now%% &mdash; turn off lazy binding
* %%-Wl,-z,relro%% &mdash; read only segments after relocation
```
$ g++ main.cpp -o main -lm -Wl,--no-as-unused
```

Использование underlinking-а приводит к следующим проблемам
* Если библиотека A, использует библиотеку B, то всякий раз нужно добавлять %%-lB%%, чтобы линковка увенчалась успехом.
* В свою очередь невозможно использование %%-Wl,--as-needed%%

* <http://edoren.me/about/>
* <http://www.bnikolic.co.uk/blog/gnu-ld-as-needed.html>
* <http://wiki.rosalab.ru/ru/index.php/Underlinking>
* <http://tldp.org/HOWTO/Program-Library-HOWTO>
* <http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html>
* <https://www.lurklurk.org/linkers/linkers.html>
* <http://www.kaizou.org/2015/01/linux-libraries>

* ((http://refspecs.freestandards.org/elf/elf.pdf ELF standard))
* ((http://www.akkadia.org/drepper/dsohowto.pdf How to Write Shared Libraries by Ulrich Drepper))
* http://www.bottomupcs.com/
* ((http://www.gentoo.org/proj/en/qa/asneeded.xml How to use GNU Linker flag --as-needed))  
* ((http://bit.ly/grMehw Plot dependency graph of a ELF file))
* Manual page for `rt-ld-audit`, `ld`, `ldd`


# Load time relocation and position independend code (PIC)
* <https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/>
* <https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries/>

Допустим, у нас есть исполняемый файл `main`, который использует функцию из библиотеки `libgeom.so`




